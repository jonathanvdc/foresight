package foresight.eqsat

/**
 * The `foresight.eqsat.rewriting` package provides the core building blocks for
 * rewrite-driven equality saturation over immutable e-graphs. It defines the
 * search/apply pipeline, mechanisms for delayed command execution, parallel search,
 * reversible rules, and match portability for caching across e-graph snapshots.
 *
 * ## Core ideas
 *
 * The system is built on **immutable e-graphs**, where every change is represented
 * as a [[foresight.eqsat.commands.Command]] value. Instead of mutating the e-graph
 * in place, commands are executed later to produce a new snapshot.
 *
 * Rules follow a **search → apply → compose** flow. A [[Searcher]] is responsible
 * for finding matches; an [[Applier]] transforms each match into a command; and
 * a [[Rule]] combines these per-match commands into a single optimized operation.
 *
 * Many methods in this package support **parallelism** through
 * [[foresight.eqsat.parallel.ParallelMap]], allowing work to be labeled and
 * distributed efficiently.
 *
 * Components are often **reversible**. A [[ReversibleSearcher]], for example, can
 * be inverted into an applier, while a [[ReversibleApplier]] can become a searcher.
 * Pipelines composed of reversible phases—via [[ReversibleSearcherPhase]]—can be
 * reversed step-by-step, and a [[Rule]] built entirely from reversible parts can
 * be flipped in its entirety using [[Rule.tryReverse]].
 *
 * Matches are also **portable**. By implementing [[PortableMatch]], a match can
 * remain meaningful across multiple e-graph snapshots, enabling caching and
 * reapplication through
 * [[foresight.eqsat.saturation.EGraphWithRecordedApplications]] and
 * [[foresight.eqsat.saturation.SearchAndApply$.withCaching]].
 *
 * ## Typical workflow
 *
 * A typical use of this package begins by defining a searcher. This is often
 * constructed from one or more phases implementing [[SearcherPhase]], which
 * perform per-class work through `search(call, egraph, input)` and aggregate
 * results across the whole graph using `aggregate(map)`. Phases can be composed
 * sequentially with [[Searcher.chain]] or run in parallel with
 * [[Searcher.product]].
 *
 * Next, an applier is defined to convert each match into a
 * [[foresight.eqsat.commands.Command]]. The searcher and applier are then paired
 * to form a [[Rule]]. Rules can be executed immediately using [[Rule.apply]], or
 * staged for later execution with [[Rule.delayed]]—either individually or batched
 * with others.
 *
 * When portability is required, caching can be introduced via
 * [[foresight.eqsat.saturation.SearchAndApply$.withCaching]], which ensures that
 * matches are recognized and skipped if they have already been applied to the
 * current e-graph state.
 *
 * ## From low-level rules to high-level saturation
 *
 * While individual rules and matchers form the foundation, higher-level orchestration
 * is handled by the saturation framework in [[foresight.eqsat.saturation]]. A
 * [[foresight.eqsat.saturation.Strategy]] composes these rules into a sequence of
 * saturation steps, controlling iteration order, stopping conditions, caching
 * behavior, and e-graph rebasing. Predefined strategies include
 * [[foresight.eqsat.saturation.MaximalRuleApplication]] (and its caching variant),
 * [[foresight.eqsat.saturation.BackoffRuleApplication]] for quota and cooldown
 * control, and [[foresight.eqsat.saturation.StochasticRuleApplication]] for
 * randomized application order.
 *
 * ## Reversal
 *
 * Reversal is a key capability for bidirectional reasoning. A
 * [[ReversibleSearcher]] can produce an applier that undoes its transformation,
 * and a [[ReversibleApplier]] can do the opposite. Pipelines can be reversed phase
 * by phase via [[ReversibleSearcherPhase.tryReverse]], and if both the searcher and
 * applier in a [[Rule]] are reversible, the entire rule can be inverted with
 * [[Rule.tryReverse]].
 *
 * ## Portability and caching
 *
 * Portability ensures that matches survive e-graph changes. A type implementing
 * [[PortableMatch]] can map its internal identifiers to the corresponding ones in
 * a new snapshot, preserving structural meaning. Purely structural matches can
 * treat `port` as a no-op, while ID-bearing matches perform translations such as
 * canonicalization. Recording and replaying matches is supported by
 * [[foresight.eqsat.saturation.EGraphWithRecordedApplications]], and caching is
 * provided by [[foresight.eqsat.saturation.SearchAndApply$.withCaching]].
 *
 * ## Design contracts
 *
 * The package assumes that searchers and phases are pure, meaning they never
 * mutate the e-graph directly. Appliers produce commands rather than making
 * in-place changes. Search and application are safe to run in parallel when
 * operating on disjoint work units. Finally, commands generated by a rule are
 * aggregated into an optimized batch and are intended to be idempotent.
 *
 * ## Quick reference
 *
 * Main entry points for search are [[Searcher]], [[SearcherPhase]],
 * [[ReversibleSearcher]], and [[ReversibleSearcherPhase]]; for application:
 * [[Applier]] and [[ReversibleApplier]]; for composition: [[Rule]]; for matches
 * across snapshots: [[PortableMatch]]; and for caching and recording:
 * [[foresight.eqsat.saturation.EGraphWithRecordedApplications]] and
 * [[foresight.eqsat.saturation.SearchAndApply$.withCaching]]. Strategies for
 * high-level orchestration include
 * [[foresight.eqsat.saturation.Strategy]],
 * [[foresight.eqsat.saturation.MaximalRuleApplication]],
 * [[foresight.eqsat.saturation.BackoffRuleApplication]], and
 * [[foresight.eqsat.saturation.StochasticRuleApplication]].
 *
 * @example Typical workflow
 * {{{
 * import foresight.eqsat.rewriting._
 * import foresight.eqsat.parallel.ParallelMap
 * import foresight.eqsat.commands.CommandQueue
 *
 * // 1) Search: single-phase searcher (returns Seq[MyMatch])
 * val s: Searcher[MyNode, Seq[MyMatch], MyEGraph] = Searcher(myPhase)
 *
 * // 2) Apply: turn a match into a Command program
 * val a: Applier[MyNode, MyMatch, MyEGraph] = (m, g) => buildCommand(m, g) // user-defined
 *
 * // 3) Rule: run now or stage/batch
 * val r = Rule("my-rule", s, a)
 * val updated = r(egraph, ParallelMap.default)                     // immediate
 * val staged  = r.delayed(egraph)                                  // staged
 * val batched = CommandQueue(Seq(staged, r2.delayed(egraph))).optimized
 * val (next, _) = batched(egraph, Map.empty, ParallelMap.default)  // execute batch
 * }}}
 *
 * @example Run with a saturation strategy
 * {{{
 * import foresight.eqsat.saturation._
 * import scala.concurrent.duration._
 *
 * val rules: Seq[Rule[MyNode, MyMatch, MyEGraph]] = Seq(r1, r2, r3)
 *
 * val strategy =
 *   MaximalRuleApplicationWithCaching(rules)
 *     .withTimeout(30.seconds)
 *     .repeatUntilStable
 *
 * val result = strategy.run(myEGraph)
 * }}}
 *
 * @example Reversal (bidirectional rules)
 * {{{
 * val forward: Rule[MyNode, MyMatch, MyEGraph] = ...
 * val maybeBack = forward.tryReverse
 * val back = maybeBack.get  // if defined, 'back' applies the inverse transformation
 * }}}
 *
 * @example Portability and caching
 * {{{
 * import foresight.eqsat.saturation._
 *
 * type M = MyMatch with PortableMatch[MyNode, M]
 * val sa = SearchAndApply.withCaching[MyNode, MyEGraph, M]
 *
 * val found: Map[String, Seq[M]] =
 *   sa.search(Seq(r1, r2), EGraphWithRecordedApplications(egraph), ParallelMap.default)
 * val after = sa.apply(Seq(r1, r2), found, EGraphWithRecordedApplications(egraph), ParallelMap.default)
 * }}}
 */
package object rewriting
